import { Code } from 'astro-expressive-code/components'
import Layout from '../layouts/index.astro'
import demo_code from '../../demo/helloworld/index.js?raw'

<Layout title='第一章 Hello, Node.js'>
  > 本章：
  > + 从重要性上讲，是第二重要
  > + 从功能上讲，是第一简单
  > + 从复杂度上讲，可能是最难理解的
  > + 所以从字数上讲，可能也是最多的

  > 我现在还不知道后面的章节有多少字。
  > 甚至我也觉得有点啰嗦。
  > 但请相信我，这些内容实在是太基础太重要了，所以我不惜冒着吓走读者的风险，啰啰嗦嗦敲下这些字。
  > 请务必仔细读完。我保证，以后绝不再提这种过分要求。

  下面的代码，可能会有点陌生，但请先尝试读一下，我会马上介绍其中的细节。

  <Code code={demo_code} lang='js' title='hello.js' showLineNumbers />

  我想激动地告诉你，这已经是一个完整的 `Node.js` 后端程序了。
  你可以复制上面的代码，粘贴到某个文件里（比如 hello.js），然后在命令行：

  ``` bash showLineNumbers=false
  node hello.js
  ```

  当看到控制台打印出 `ok` 时，这个后端程序已经起来了。
  现在你可以在浏览器输入 http://127.0.0.1:8080/ 来访问这个服务器了。
  下面我来介绍一下这几行代码。

  #### 第一行
  > 巧了，第一行是本章最重要的一行，也是所有章节里最重要的一行。

  前端程序员应该不陌生，js 的世界里，存在两种模块化方案：cjs 和 esm。  
  而 `const http = require('http')` 是 `Node.js` 默认的方案。

  不管是 `import` 还是 `require` 我们都知道是“导入”某模块或库，
  比如前端常见的 `import React from 'react'` 是导入 React。
  而 `react`，一般是通过 npm 安装的：

  ``` bash showLineNumbers=false
  npm install react
  ```

  npm 会帮我们下载 react，然后放到 node_modules 文件夹里。  
  那么 `const http = require('http')` 里的 `http` 模块是哪来的呢？  
  答：是 `Node.js` 里的。

  就像我们在写前端代码时，可以使用 `window`, `document`, `fetch`, `localStorage`……  
  我们把这些东西叫做浏览器的“**内置对象**”。  

  而 `http` 模块是 `Node.js` 的“**内置模块**”。  

  重点来了：
  + 前端代码是运行在浏览器里的，而我们现在写的 `hello.js` 是运行在 `Node.js` 里的
  + `Node.js` 和浏览器是两个不一样的“js 代码解释器”，或者换句话说，是两个不同的“执行 js 程序的程序”

  > 到这里，本章、所有章的重点都讲完了，请舒一口气后继续。

  `http 模块` 里包含一些处理 “http 通信” 相关的东西：
  + 发送 http 请求，就像在前端常用的 axios 或 fetch
  + 接收 http 请求，这是前端没有的功能

  接收 http 请求？下面是一个用 axios 发送请求（创建一个用户）的例子：
  ``` js
  const res = await axios.post('http://1.2.3.4:8080/user', {
    name: 'PPz',
    year: 3,
  })
  ```

  在底层，浏览器会发送一个 `POST` 请求，到 ip 为 1.2.3.4 的电脑上。  
  这个电脑有可能是一个家用电脑，有鼠标、键盘、显示器；  
  也可能是服务器机房里，某个架子上的、一台黑乎乎的长方体盒子；  
  也可能是某个云服务提供商（比如阿里云、腾讯云）的一台“大电脑”里的某个虚拟机；  
  也可能……

  这个过程，跟用手机发短信很类似：
  + 输入短信内容（比如“帮我带饭，二楼的麻辣烫，加辣”）
  + 输入手机号（表示发送到谁的手机上）

  ip 为 1.2.3.4 的电脑收到数据后，
  这台电脑，会把接收到的数据，交给端口号为 8080 的程序，
  （这台电脑上可能有很多“后端程序”，因此需要一个“编号”，也就是端口号），
  等程序处理完，一般会都会**回信息**，比如“带饭请求已收到，但我不想给你带。”。  
  这个“回信息”，在 http 通信里，叫“响应”。
  响应由服务器发送给客户端，最终由 axios 交到一个叫 `res` 的变量里（看上面那个 axios 例子）。

  下面我们继续聊 `hello.js` 的第 3 到 10 行。
  因为不那么重要，而且很简单，因此内容很少。

  #### 第 3~8 行
  这 5 行代码，很像前端添加“点击事件”监听器：
  ``` js
  document.getElementById('target').addEventListener('click', () => {
    // 这里的代码，在“用户点击”后会执行
    console.log('点了一下')
  })
  ```
  而这 5 行代码的意思是：当收到 http 请求，执行：
  ``` js
  console.log('收到请求', new Date()) // 打印日志
  res.write('Hello, Node.js') // 回信内容（响应内容）
  res.end() // 回信完毕
  ```

  这两行代码，不管收到的是什么请求、附带了什么数据，都响应 `Hello, Node.js`。
  所以，你可以打开 postman，尝试发一个 POST 请求，或一个怪异的 url，再加一些数据，
  只要 ip 和 端口号不变，这个请求就能到 hello.js 这个程序里，就只能返回 `Hello, Node.js`。

  #### 第 9 行
  在第 3~8 行，我们创建了一个 http server 对象，
  创建后，它不会马上开始工作，
  而是等我们调用 `server.listen()` 方法后，才正式开始。

  在第 9 行，我们调用了 `server.listen()` 方法，并顺便传过去一个端口号（8080），
  于是这个后端程序就开始工作了。

</Layout>
